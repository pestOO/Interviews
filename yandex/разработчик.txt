class Foo {
public:
    explicit Foo(std::size_t j) : array_of_int(j)
        {}
    virtual  ~Foo() { }
private:
    std::vector<int> array_of_int;
};

class Bar: public Foo {
public:
    explicit Bar(std::size_t j) : Foo(j), array_of_char(j)
        {}
private:
    std::vector<int> array_of_char;
};

1. Класс Bar "private" унаследован от класса Foo (по умолчанию, т.к. модификатор не указан), что вызовет ошибку этапа компиляции при сохранении объекта типа Bar как указатель Foo*.
	Решение: добавить модификатор наследования public.

2. При удалении объекта Bar, хранящегося как указатель на Foo* не будет вызван деструктор ~Bar(), что приведет к утечке памяти.
	Решение: добавить модификатор virtual деструктору ~Foo().

3. У класса Foo отсутвует конструктор по умолчанию, что приведет к ошибке этапа компиляции.
	Решение: добавить конструктор по умолчанию Foo() или добавить вызов существующего Foo(int) в зависимости от требуемого поведения
 
4.1 При копировании одного объекта классов Foo/Bar в другой объект этого же типа будет скопировано значение указателя 'i' (сгенерированный по умолчанию оператор присваивания), что приведет в момент уничтожения 2го элемента к двойному удалению i и ошибке сегментации.
	Решение: реализовать корректный оператор присваивания или перейти на хранение данных в контейнерах.

4.2 При инициализации одного объекта классов Foo/Bar другим объект этого же типа будет скопировано значение указателя 'i' (сгенерированный по умолчанию конструктор копирования), что приведет в момент уничтожения 2го элемента к двойному удалению i и ошибке сегментации.
	Решение: реализовать корректный конструктор копирования или перейти на хранение данных в контейнерах.
	
5. В деструкторах классов происходит удаление скаляров, а не массивов.
	Решение: изменить оператор delete на delete[] или перейти на хранение данных в контейнерах.
 
6. При вызове конструктора с отрицательным значением j будет "ожидается" неопределенное поведение
	Решение: изменить тип принимаемого значения с int на unisigned int или std::size_t
	
7. Из-за одинакового имени приватного поля ‘i’ возможны ошибки при дальнейшем использовании классов Foo и Bar. (Так же именам 'i' не хватает представления сущсности, которую они хранят).
	Решение: Изменить имена полей на более "понятные".

8. Классы Bar и Foo обладают конструкторами позволяющими непреднамеренное преобразование (Пример: Foo f = 10;)
	Решение: Добавить конструкторам модификатор explicit

9. Функция main не возвращает значение, что приведет к ошибке этапа компиляции (для с++).
	Решение : добавить функции main возвращаемый тип int и оператор return c аргументом 0 (или EXIT_SUCCESS) в конец тела функции.
